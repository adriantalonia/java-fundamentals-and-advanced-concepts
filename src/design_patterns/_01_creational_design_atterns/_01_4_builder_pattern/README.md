## Builder Design Pattern

In general, the details of object construction, such as instantiating and initializing the components that make up the
object, are kept within the object, often as part of its constructor. This type of design closely ties the object
construction process with the components that make up the object. However, this approach is suitable as long as the
object under construction is simple and the object construction process is definite and always produces the same
representation of the object.

Moreover, this design may not be effective when the object being created is complex and the series of steps constituting
the object creation process can be implemented in different ways. Thus, producing different representations of the
object. Because the different implementations of the construction process are all kept within the object, the object can
become bulky (construction bloat) and less modular. Subsequently, adding a new implementation or making changes to an
existing implementation requires changes to the existing code.

### Builder

It specifies an abstract interface for creating parts of a Product object. The Builder Pattern suggests moving the
construction logic out of the object class to a separate class referred to as a builder class. However, there can be
more than one such builder classes, each with different implementations for the series of steps to construct the object.
Moreover, each builder implementation results in a different representation of the object.

### ConcreteBuilder

Constructs and assembles parts of the product by implementing the Builder interface.
Defines and keeps track of the representation it creates.
Provides an interface for retrieving the product.

### Director

It constructs an object using the Builder interface. The Builder pattern suggests using a dedicated object referred to
as a Director, which is responsible for invoking different builder methods required for the construction of the final
object. Moreover, different client objects can make use of the Director object to create the required object. Once the
object is constructed, the client object can directly request from the builder the fully constructed object. In order to
facilitate this process, a new method getObject () can be declared in the common Builder interface to be implemented by
different concrete builders.

### Product

Represents the complex object under construction. Further, ConcreteBuilder builds the product’s internal representation
and defines the process by which it’s assembled.
Includes classes that define the constituent parts, including interfaces for assembling the parts into the final result.

![image](https://media.geeksforgeeks.org/wp-content/uploads/uml-of-builedr.jpg)

- **Product** – The product class defines the type of the complex object that is to be generated by the builder pattern.
- **Builder** – This abstract base class defines all of the steps that must be taken in order to correctly create a product.
  Each step is generally abstract as the actual functionality of the builder is carried out in the concrete subclasses.
  The GetProduct method is used to return the final product. The builder class is often replaced with a simple
  interface.
- **ConcreteBuilder** – There may be any number of concrete builder classes inheriting from Builder. These classes contain
  the
  functionality to create a particular complex product.
- **Director** – The director-class controls the algorithm that generates the final product object. A director object is
  instantiated and its Construct method is called. The method includes a parameter to capture the specific concrete
  builder object that is to be used to generate the product. The director then calls methods of the concrete builder in
  the correct order to generate the product object. On completion of the process, the GetProduct method of the builder
  object can be used to return the product.

### Example

```java
public interface MealBuilder {

    public void buildStarter();

    public void buildMainCourse();

    public void buildDesserts();

    public Meal getMeal();
}
```

```java
public class Meal {

    private String starter;
    private String mainCourse;
    private String desserts;

    public String getStarter() {
        return starter;
    }

    public void setStarter(String starter) {
        this.starter = starter;
    }

    public String getMainCourse() {
        return mainCourse;
    }

    public void setMainCourse(String mainCourse) {
        this.mainCourse = mainCourse;
    }

    public String getDesserts() {
        return desserts;
    }

    public void setDesserts(String desserts) {
        this.desserts = desserts;
    }

    @Override
    public String toString() {
        return "Meal [starter=" + starter + ", mainCourse=" + mainCourse
                + ", desserts=" + desserts + "]";
    }
}
```

```java
public class IndianMealBuilder implements MealBuilder {

    Meal meal;

    public IndianMealBuilder() {
        meal = new Meal();
    }

    @Override
    public void buildStarter() {
        meal.setStarter("Indian Starter");
    }

    @Override
    public void buildMainCourse() {
        meal.setMainCourse("Indian MainCourse");
    }

    @Override
    public void buildDesserts() {
        meal.setDesserts("Indian Desserts");
    }

    @Override
    public Meal getMeal() {
        return meal;
    }
}
```

```java
public class MealDirector {

    private MealBuilder mealBuilder = null;

    public MealDirector(MealBuilder mealBuilder) {
        this.mealBuilder = mealBuilder;
    }

    public void constructMeal() {
        mealBuilder.buildStarter();
        mealBuilder.buildMainCourse();
        mealBuilder.buildDesserts();
    }

    public Meal getMeal() {
        return mealBuilder.getMeal();
    }
}
```

```java
public class BuilderTest {

    public static void main(String[] args) {

        MealBuilder indianMealBuilder = new IndianMealBuilder();
        MealDirector mealDirector = new MealDirector(indianMealBuilder);
        mealDirector.constructMeal();
        Meal meal = mealDirector.getMeal();
        System.out.println("Requested meal is :" + meal);
    }
}
```

**Output:**
> Requested meal is :Meal [starter=Indian Starter, mainCourse=Indian MainCourse, desserts=Indian Desserts]
